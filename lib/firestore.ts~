import type { Product, ProductKit, StockMovement } from "./types";
import { ensureFirebase } from "./firebase-client";

export interface StockOutInput {
  sku: string;
  qty: number;
  userId: string;
  userName: string;
}

export interface StockOutResult {
  product: Product;
  // KIT-SKU START
  kit: ProductKit | null;
  effectiveQty: number;
  scannedSku: string;
  // KIT-SKU END
}

// KIT-SKU START
export interface ResolvedSkuResult {
  product: Product;
  kit: ProductKit | null;
  sanitizedSku: string;
}

function normalizeKits(raw: any): ProductKit[] {
  if (!Array.isArray(raw)) {
    return [];
  }
  return raw
    .map((item) => {
      if (!item || typeof item !== "object") {
        return null;
      }
      const sku = typeof item.sku === "string" ? item.sku.trim() : "";
      if (!sku) {
        return null;
      }
      const label = typeof item.label === "string" ? item.label.trim() : "";
      const rawMultiplier = Number(item.multiplier ?? 1);
      const multiplier = Number.isFinite(rawMultiplier) ? Math.max(1, Math.floor(rawMultiplier)) : 1;
      return {
        sku,
        label,
        multiplier
      } satisfies ProductKit;
    })
    .filter((kit): kit is ProductKit => Boolean(kit));
}

function normalizeKitSkus(raw: any): string[] {
  if (!Array.isArray(raw)) {
    return [];
  }
  return raw
    .map((value) => (typeof value === "string" ? value.trim() : ""))
    .filter((value) => value.length > 0);
}

export function mapProductDoc(doc: any): Product {
  const data = doc.data() ?? {};
  const kits = normalizeKits(data.kits);
  const kitSkus = normalizeKitSkus(data.kitSkus);
  const product: Product = {
    id: doc.id,
    name: typeof data.name === "string" ? data.name : "",
    sku: typeof data.sku === "string" ? data.sku : "",
    unitPrice: Number(data.unitPrice ?? 0),
    category: typeof data.category === "string" && data.category.length ? data.category : undefined,
    supplier: typeof data.supplier === "string" && data.supplier.length ? data.supplier : undefined,
    quantity: Number(data.quantity ?? 0),
    totalValue: Number(data.totalValue ?? 0),
    estoqueMinimo: typeof data.estoqueMinimo === "number" ? data.estoqueMinimo : undefined
  };
  if (kits.length) {
    product.kits = kits;
  }
  if (kitSkus.length) {
    product.kitSkus = kitSkus;
  }
  return product;
}

export async function resolveSkuToParentAndMultiplier(
  sku: string,
  existingBundle?: any
): Promise<ResolvedSkuResult | null> {
  const sanitizedSku = typeof sku === "string" ? sku.trim() : "";
  if (!sanitizedSku) {
    return null;
  }

  const bundle = existingBundle ?? (await ensureFirebase());
  const { firestore, db } = bundle;
  const productsRef = firestore.collection(db, "products");

  const parentQuery = firestore.query(
    productsRef,
    firestore.where("sku", "==", sanitizedSku),
    firestore.limit(1)
  );
  const parentSnapshot = await firestore.getDocs(parentQuery);
  if (!parentSnapshot.empty) {
    const doc = parentSnapshot.docs[0];
    return {
      product: mapProductDoc(doc),
      kit: null,
      sanitizedSku
    };
  }

  const kitQuery = firestore.query(
    productsRef,
    firestore.where("kitSkus", "array-contains", sanitizedSku),
    firestore.limit(1)
  );
  const kitSnapshot = await firestore.getDocs(kitQuery);
  if (kitSnapshot.empty) {
    return null;
  }

  const doc = kitSnapshot.docs[0];
  const product = mapProductDoc(doc);
  const kit = (product.kits ?? []).find((item) => item.sku === sanitizedSku) ?? null;
  if (!kit) {
    return null;
  }

  return {
    product,
    kit,
    sanitizedSku
  };
}
// KIT-SKU END

export async function getProductBySku(sku: string): Promise<Product | null> {
  const resolved = await resolveSkuToParentAndMultiplier(sku);
  return resolved ? resolved.product : null;
}


  const bundle = await ensureFirebase();
  const { firestore, db } = bundle;
  const productsRef = firestore.collection(db, "products");
  const query = firestore.query(productsRef, firestore.where("sku", "==", sanitized), firestore.limit(1));
  const snapshot = await firestore.getDocs(query);

  if (snapshot.empty) {
    return null;
  }

  const doc = snapshot.docs[0];
  const data = doc.data();
  return { id: doc.id, ...data } as Product;
}

export async function processStockOut(input: StockOutInput): Promise<StockOutResult> {
  const { sku, qty, userId, userName } = input;
  if (!userId) {
    throw new Error("Usuario nao autenticado.");
  }

  const numericQty = Number(qty);
  if (!Number.isFinite(numericQty) || numericQty <= 0) {
    throw new Error("Informe uma quantidade valida.");
  }

  const bundle = await ensureFirebase();
  const { firestore, db } = bundle;

  const resolved = await resolveSkuToParentAndMultiplier(sku, bundle);
  if (!resolved) {
    throw new Error("Produto nao encontrado para este SKU.");
  }

  const { product, kit, sanitizedSku } = resolved;
  const baseQty = Math.max(1, Math.floor(numericQty));
  const multiplier = kit?.multiplier ?? 1;
  const effectiveQty = baseQty * multiplier;

  if (effectiveQty <= 0) {
    throw new Error("Informe uma quantidade valida.");
  }

  const productRef = firestore.doc(db, "products", product.id);

  let updatedProduct: Product | null = null;

  await firestore.runTransaction(db, async (transaction: any) => {
    const snapshot = await transaction.get(productRef);
    if (!snapshot.exists()) {
      throw new Error("Produto nao encontrado.");
    }

    const data = snapshot.data();
    const currentQuantity = Number(data.quantity ?? 0);
    const unitPrice = Number(data.unitPrice ?? 0);

    if (currentQuantity < effectiveQty) {
      throw new Error("Estoque insuficiente para essa saida.");
    }

    const newQuantity = currentQuantity - effectiveQty;
    const newTotalValue = Number((newQuantity * unitPrice).toFixed(2));

    transaction.update(productRef, {
      quantity: newQuantity,
      totalValue: newTotalValue
    });

    const movementsRef = firestore.collection(db, "stockMovements");
    const movementRef = firestore.doc(movementsRef);

    transaction.set(movementRef, {
      id: movementRef.id,
      productId: productRef.id,
      sku: product.sku,
      qty: effectiveQty,
      type: "out",
      userId,
      userName: userName || "desconhecido",
      timestamp: firestore.serverTimestamp(),
      // KIT-SKU START
      parentSku: product.sku,
      scannedSku: sanitizedSku,
      multiplier,
      effectiveQty
      // KIT-SKU END
    });

    const kits = normalizeKits(data.kits);
    const kitSkus = normalizeKitSkus(data.kitSkus);

    const nextProduct: Product = {
      id: productRef.id,
      name: typeof data.name === "string" ? data.name : "",
      sku: typeof data.sku === "string" ? data.sku : "",
      unitPrice,
      category: typeof data.category === "string" && data.category.length ? data.category : undefined,
      supplier: typeof data.supplier === "string" && data.supplier.length ? data.supplier : undefined,
      quantity: newQuantity,
      totalValue: newTotalValue,
      estoqueMinimo: typeof data.estoqueMinimo === "number" ? data.estoqueMinimo : undefined
    };

    if (kits.length) {
      nextProduct.kits = kits;
    }

    if (kitSkus.length) {
      nextProduct.kitSkus = kitSkus;
    }

    updatedProduct = nextProduct;
  });

  if (!updatedProduct) {
    throw new Error("Falha ao atualizar o produto.");
  }

  return {
    product: updatedProduct,
    kit,
    effectiveQty,
    scannedSku: sanitizedSku
  };
}

export interface StockMovementsFilters {
  limit?: number;
  startAfter?: any;
  sku?: string;
  userId?: string;
  type?: "out" | "in";
  range?: { start?: Date | null; end?: Date | null };
}

export interface StockMovementWithProduct extends StockMovement {
  productName?: string;
}

export interface StockMovementsPage {
  movements: StockMovementWithProduct[];
  nextCursor: any;
}

export async function fetchStockMovements(filters: StockMovementsFilters): Promise<StockMovementsPage> {
  const bundle = await ensureFirebase();
  const { firestore, db } = bundle;
  const ref = firestore.collection(db, "stockMovements");

  const constraints: any[] = [];

  if (filters.type) {
    constraints.push(firestore.where("type", "==", filters.type));
  }

  if (filters.sku) {
    constraints.push(firestore.where("sku", "==", filters.sku.trim()));
  }

  if (filters.userId) {
    constraints.push(firestore.where("userId", "==", filters.userId));
  }

  if (filters.range?.start) {
    constraints.push(
      firestore.where("timestamp", ">=", firestore.Timestamp.fromDate(filters.range.start))
    );
  }

  if (filters.range?.end) {
    constraints.push(
      firestore.where("timestamp", "<=", firestore.Timestamp.fromDate(filters.range.end))
    );
  }

  constraints.push(firestore.orderBy("timestamp", "desc"));

  const pageLimit = filters.limit ?? 25;

  if (filters.startAfter) {
    constraints.push(firestore.startAfter(filters.startAfter));
  }

  constraints.push(firestore.limit(pageLimit));

  const query = firestore.query(ref, ...constraints);
  const snapshot = await firestore.getDocs(query);

  const movements: StockMovementWithProduct[] = snapshot.docs.map((doc: any) => {
    const data = doc.data();
    const timestampValue = data.timestamp && typeof data.timestamp.toMillis === "function"
      ? data.timestamp.toMillis()
      : Number(data.timestamp ?? 0);
    return {
      id: doc.id,
      productId: data.productId,
      sku: data.sku,
      qty: data.qty,
      type: data.type,
      userId: data.userId,
      userName: data.userName,
      timestamp: timestampValue
    };
  });

  const productIds = Array.from(
    new Set(
      movements
        .map((movement) => movement.productId)
        .filter((id): id is string => Boolean(id))
    )
  );

  const productNames = await loadProductNames(productIds);

  const enriched = movements.map((movement) => ({
    ...movement,
    productName: productNames.get(movement.productId ?? "") ?? ""
  }));

  const nextCursor = snapshot.docs.length === pageLimit ? snapshot.docs[snapshot.docs.length - 1] : null;

  return { movements: enriched, nextCursor };
}

export async function fetchStockMovementsForExport(
  filters: StockMovementsFilters,
  maxRecords = 1000
): Promise<StockMovementWithProduct[]> {
  const mergedFilters = { ...filters };
  let cursor = mergedFilters.startAfter ?? null;
  const collected: StockMovementWithProduct[] = [];

  while (collected.length < maxRecords) {
    const { movements, nextCursor } = await fetchStockMovements({
      ...mergedFilters,
      startAfter: cursor,
      limit: Math.min(200, maxRecords - collected.length)
    });

    collected.push(...movements);

    if (!nextCursor || movements.length === 0) {
      break;
    }

    cursor = nextCursor;
  }

  return collected.slice(0, maxRecords);
}

export interface MovementUserOption {
  id: string;
  name: string;
  email: string;
  role: string;
}

export async function fetchMovementUsers(): Promise<MovementUserOption[]> {
  const bundle = await ensureFirebase();
  const { firestore, db } = bundle;
  const usersRef = firestore.collection(db, "users");
  const snapshot = await firestore.getDocs(usersRef);

  return snapshot.docs.map((doc: any) => {
    const data = doc.data();
    return {
      id: doc.id,
      name: data.displayName || data.email || "desconhecido",
      email: data.email || "",
      role: data.role || "staff"
    };
  });
}

async function loadProductNames(ids: string[]): Promise<Map<string, string>> {
  if (!ids.length) {
    return new Map();
  }

  const bundle = await ensureFirebase();
  const { firestore, db } = bundle;
  const unique = Array.from(new Set(ids));
  const map = new Map<string, string>();

  await Promise.all(
    unique.map(async (id) => {
      try {
        const docRef = firestore.doc(db, "products", id);
        const snapshot = await firestore.getDoc(docRef);
        if (snapshot.exists()) {
          const data = snapshot.data();
          map.set(id, data.name ?? "");
        }
      } catch (error) {
        console.error("Falha ao carregar nome do produto", error);
      }
    })
  );

  return map;
}










